# 401 未授权问题修复说明

## 问题原因

前端 `Login.tsx` 中调用 store 的 `login` 函数时，传递的参数不正确，导致用户信息和 token 没有正确保存到 store 中。

## 已修复的代码

### 文件：`views/Login.tsx`

**修改前（第 24-36 行）：**
```typescript
if (response.code === 200) {
  // 保存Token和用户信息
  localStorage.setItem('token', response.data.token);
  localStorage.setItem('user', JSON.stringify(response.data.userInfo));

  // 更新Store
  login(response.data.userInfo.username); // ❌ 错误：只传递了用户名

  // 跳转到仪表盘
  navigate('/dashboard');
}
```

**修改后：**
```typescript
if (response.code === 200) {
  // 更新Store（Store 内部会自动保存到 localStorage）
  login(response.data.userInfo, response.data.token); // ✅ 正确：传递完整对象和 token

  // 跳转到仪表盘
  navigate('/dashboard');
}
```

## 验证步骤

### 1. 清除浏览器缓存

打开浏览器开发者工具（F12），执行以下操作：

1. 打开 **Application（应用）** 标签页
2. 在左侧找到 **Local Storage**
3. 点击你的应用域名（如 `http://localhost:5173`）
4. 点击 **Clear All（全部清除）** 按钮
5. 刷新页面

### 2. 重新登录

1. 访问登录页面
2. 使用以下任意账号登录：
   - **管理员账号**：
     - 用户名：`admin`
     - 密码：任意（后端暂时跳过密码验证）
   - **普通用户账号**：
     - 用户名：`user`
     - 密码：任意
   - **访客账号**：
     - 用户名：`guest`
     - 密码：任意

### 3. 验证菜单加载

登录成功后，打开浏览器开发者工具的 **Network（网络）** 标签页，观察以下请求：

1. **查找请求**：`/api/menus/user-menus`
2. **检查请求头**：
   - 应包含 `Authorization: Bearer <token>`
   - Token 应该是一个长字符串（JWT 格式）
3. **检查响应**：
   - 状态码应为 `200`
   - 响应数据应包含菜单列表

## 后端 JWT 验证测试

我已经通过 PowerShell 脚本验证了后端的 JWT 认证功能正常，测试结果如下：

### 测试脚本：`backend/test-jwt.ps1`

```powershell
# 1. 登录
$loginResponse = Invoke-RestMethod -Uri "http://localhost:8080/api/auth/login" -Method Post ...
# ✅ 成功：返回 token 和用户信息

# 2. 使用 token 获取菜单
$menusResponse = Invoke-RestMethod -Uri "http://localhost:8080/api/menus/user-menus" -Method Get -Headers @{ "Authorization" = "Bearer $token" }
# ✅ 成功：返回菜单数据
```

## 其他注意事项

### 默认账号和权限

- **admin**（超级管理员）：拥有所有菜单和按钮权限
- **user**（普通用户）：仅拥有仪表盘和文章管理权限
- **guest**（访客）：仅拥有仪表盘和文章列表查看权限

### 前端默认密码更新

`Login.tsx` 中的默认密码已设置为 `123456`，您可以根据需要修改（因为后端暂时跳过密码验证）。

## 常见问题排查

### 如果仍然遇到 401 错误

1. **检查 localStorage**：
   - 打开浏览器开发者工具 → Application → Local Storage
   - 确认存在 `token` 和 `user` 两个键值对
   - Token 应该是一个 JWT 格式的字符串

2. **检查请求头**：
   - 打开 Network 标签页
   - 查看失败的请求
   - 确认 `Authorization` 请求头格式为：`Bearer <token>`

3. **查看后端日志**：
   - 后端控制台会打印调试信息：
     ```
     [DEBUG] Request URI: /api/menus/user-menus
     [DEBUG] Authorization Header: Bearer eyJhbGci...
     [DEBUG] Extracted Token: eyJhbGci...
     [DEBUG] User ID from token: 1
     ```
   - 如果看到 `Token validation failed`，说明 token 验证失败

4. **重启后端服务**：
   - 停止后端应用
   - 重新运行 `mvn spring-boot:run`
   - 确保使用 Java 17

## Java 版本说明

您的环境已确认使用 Java 17.0.2：
```
Java version: 17.0.2, vendor: Oracle Corporation
```

这与 `pom.xml` 中配置的 Java 17 版本一致，**无需更改 Java 版本**。

之前提到的 "Java 17 兼容性问题" 经过测试验证，**实际上后端工作正常**，问题完全出在前端的登录逻辑。

## 总结

- ✅ **问题已修复**：`Login.tsx` 中的 `login` 函数调用已修正
- ✅ **后端正常**：JWT 认证机制经过测试验证工作正常
- ✅ **Java 版本正确**：Java 17 与项目配置一致
- ⚠️ **需要测试**：请清除浏览器缓存并重新登录以验证修复

如果按照上述步骤操作后仍有问题，请提供：
1. 浏览器开发者工具的 Network 标签页截图
2. 后端控制台的日志输出
3. localStorage 中的内容
